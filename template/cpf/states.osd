StateMachine HomeAxisMachine
{
    param int axis
    // 1 or -1: direction to get to a switch transition when switch = 1
    param double switch_dir 
    param double vel_fast
    param double vel_slow 

    var int j
    var bool switch_state
    
    
    initial state HomingInitialState {
        entry {
            if Kuka160RefSensor.getReference(axis) then
            {
                 set vel_fast =        vel_fast * switch_dir
                 set vel_slow = -1.0 * vel_slow * switch_dir
                 set switch_state = true
            }
            else
            {
                 set vel_fast = -1.0 * vel_fast * switch_dir
                 set vel_slow =        vel_slow * switch_dir
                 set switch_state = false
            }
        }

        exit {
        }
        transitions {
                select DriveFastState
        }
     }
    

    state DriveFastState {
        entry {
  	  do nAxesGeneratorVel.gotoVelocity(axis, vel_fast,0.0); 	
        }
        exit {
	  do nAxesGeneratorVel.gotoVelocity(axis, 0.0 ,0.0); 	
        }
        transitions {
            if ( !Kuka160RefSensor.getReference(axis) && switch_state ) then
                select DriveSlowState
            if ( Kuka160RefSensor.getReference(axis) && !switch_state ) then
                select DriveSlowState
        }
    }

    state DriveSlowState {
        entry {
	  do nAxesGeneratorVel.gotoVelocity(axis, vel_slow ,0.0); 	
        }
        exit {
	  do Robot.initPosition(axis)
	  do nAxesControllerVel.resetAxis(axis)
	  do nAxesGeneratorVel.gotoVelocity(axis, 0.0 ,0.0); 	
        }
        transitions {
            if ( Kuka160RefSensor.getReference(axis) && switch_state ) then
                select HomingFinalState
            if ( !Kuka160RefSensor.getReference(axis) && !switch_state ) then
                select HomingFinalState
        }
    }

    final state HomingFinalState {
        entry {
        }
        exit {
        }
    }
}







StateMachine Default
{
  var bool calibrate_offsets     = true
  var bool execute_path          = false

  const double pi = 3.14159265358979

  var frame frame_env_obj = frame(rotation(0.0, 0.0, 0.0),vector(0.4, 0.3, 0.2))

  SubMachine HomeAxisMachine Home_axis_1( axis=0, switch_dir=1.0, vel_fast=0.02, vel_slow=0.003 )
  SubMachine HomeAxisMachine Home_axis_2( axis=1, switch_dir=1.0, vel_fast=0.02, vel_slow=0.003 )
  SubMachine HomeAxisMachine Home_axis_3( axis=2, switch_dir=-1.0, vel_fast=0.02, vel_slow=0.003 )
  SubMachine HomeAxisMachine Home_axis_4( axis=3, switch_dir=1.0, vel_fast=0.02, vel_slow=0.003 )
  SubMachine HomeAxisMachine Home_axis_5( axis=4, switch_dir=1.0, vel_fast=0.02, vel_slow=0.003 )
  SubMachine HomeAxisMachine Home_axis_6( axis=5, switch_dir=1.0, vel_fast=0.02, vel_slow=0.003 )


  initial state StartRobotState {
    entry {
      do Robot.start()	
      do Robot.prepareForUse()
    }
    exit {
      do Robot.unlockAllAxes()
      do Robot.startAllAxes()
    }
    transitions {
      select CalibrateOffsetsState
    }
  }


  state CalibrateOffsetsState {
    preconditions {
      if (calibrate_offsets == false) then
        select ExecutionState
    }
    entry {
      do nAxesSensor.start()
      do nAxesGeneratorPos.start()
      do nAxesControllerPos.start()
      do nAxesEffectorVel.start()
      do programs.CalibrateOffsetsProg.start()
    }
    exit {
      do nAxesSensor.stop()
      do nAxesGeneratorPos.stop()
      do nAxesControllerPos.stop()
      do nAxesEffectorVel.stop()
    }
    transitions {
      if !programs.CalibrateOffsetsProg.isRunning then
       select HomingState
    }
  }      


  state HomingState 
    {
      entry {
         do nAxesSensor.start()
         do nAxesGeneratorVel.start()
         do nAxesControllerVel.start()
         do nAxesEffectorVel.start()

	 // Startup all the submachines at once 
	 do Home_axis_1.activate()
	 do Home_axis_1.start()
	 do Home_axis_2.activate()
	 do Home_axis_2.start()
	 do Home_axis_3.activate()
	 do Home_axis_3.start()
	 do Home_axis_4.activate()
	 do Home_axis_4.start()
	 do Home_axis_5.activate()
	 do Home_axis_5.start()
	 do Home_axis_6.activate()
	 do Home_axis_6.start()
    }

	exit {
         do nAxesSensor.stop()
         do nAxesGeneratorVel.stop()
         do nAxesControllerVel.stop()
         do nAxesEffectorVel.stop()
       }

    transitions {
      if (Home_axis_1.inState("HomingFinalState") && 
          Home_axis_2.inState("HomingFinalState") && 
	  Home_axis_3.inState("HomingFinalState") && 
	  Home_axis_4.inState("HomingFinalState") && 
	  Home_axis_5.inState("HomingFinalState") && 
	  Home_axis_6.inState("HomingFinalState")) then
		select ExecutionState
    }
  }


  state ExecutionState {
    preconditions {
      if (execute_path == false) then
        select StopRobotState
    }
    entry {
      // move to initial position
      do MoveToJoint(-pi/2, -0.4, 1.5, 0.07, pi/2, -0.17)
      do MoveToCartesian(Execution.frame_robot_env * frame_env_obj * Execution.frame_obj_ee)

      // calibrate wrench sensor
      do Wrenchsensor.start()
      do CartesianSensor.start()
      do Execution.start()
      do Execution.calibrateWrenchSensor()
      do CartesianEffectorVel.start()
      do Estimation.start()
      do Reporting.start()
    }
    exit {
      do Reporting.stop()
      do Estimation.stop()
      do CartesianEffectorVel.stop()
      do Execution.stop()
      do CartesianSensor.stop()
      do Wrenchsensor.stop()

      do MoveToCartesian(Execution.frame_robot_env * frame_env_obj * Execution.frame_obj_ee)
    }
    transitions {
      if (Execution.trajectoryFinished()) then
        select StopRobotState
    }
  }



  final state StopRobotState {
    entry {
      do MoveToJoint(-0.2508, -0.92, 2.18, 0.07, 0.15, -0.2)
      do Robot.stopAllAxes()
      do Robot.lockAllAxes()
    }
    exit {
      do Robot.prepareForShutdown()
      do Robot.stop()
    }
  }
}

RootMachine Default Default
