#+TITLE:	Lua RTT bindings (beta1)
#+AUTHOR:	Markus Klotzbuecher
#+EMAIL:	markus.klotzbuecher@mech.kuleuven.be
#+DATE:		2010-09-13 Mon
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:	en
#+OPTIONS:	H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:	TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT:	view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:
#+STYLE:	<link rel="stylesheet" type="text/css" href="css/stylesheet.css" />

#+STARTUP:	showall
#+STARTUP:	hidestars

* Overview

  The RTT Lua bindings provide a slim but powerful interface to the
  RTT framework. It can be used for:

  - for building Lua based domain specific languages in the RTT
  - as a scriptable taskbrowser and deployer
  - for fast prototyping of components

  These bindings can be used in three different ways:

   1. As a *RTT enabled Lua interpreter*

      This is the easiest way to test a script and see if it works or
      for use as a scriptable deployer.

   2. As a *Lua component*

      A Lua component which offers two operations. The first for
      executing a given lua script and the second for executing a
      string with lua code.

   3. As a *RTT plugin*

      A /Lua Service/ can be loaded into a component and used e.g. for
      /intra-component/ coordination. It offers the same API as the
      Lua component.

  The Lua API consists of objects and free functions. The API naming
  mostly follows that RTT while simplifying where possible.


* Setup

** Compilation

   - requires Lua-5.1 (debian: =liblua5.1-0-dev=, =liblua5.1-0=, =lua5.1=)

** Runtime

    - setup =LUA_PATH= and =LUA_CPATH= so that the necessary modules
      are found. The former is for lua modules (.lua) and the later is
      for binary ones (.so). For example:

#+BEGIN_EXAMPLE
      $ export LUA_PATH=";;;/usr/share/lua/5.1/?.lua;\
	      /usr/share/lua/5.1/?/init.lua;\
	      /home/mk/src/git/orocos/ocl/lua/lua-modules/?.lua"
#+END_EXAMPLE

    - if using =rttlua= scripting: export correct =RTT_COMPONENT_PATH=
      variable, e.g.

#+BEGIN_EXAMPLE
      $ export RTT_COMPONENT_PATH=/home/mk/tmp/rtt-2.0/lib/orocos:home/mk/src/git/ocl/lua
#+END_EXAMPLE

* Quickstart

  Run the =rttlua= interpreter:

#+BEGIN_EXAMPLE
  ./rttlua
  Orocos RTTLua 1.0-beta1 (gnulinux)
  > -- print the TaskContext Lua is running in
  > print(TC)
  userdata: 0x1cba0b8
  > -- if we want nicer output we must load the rttlib module
  > require("modules/rttlib")
  > print(TC)
  TaskContext: lua
  state: PreOperational
  [...]
  > -- enable colors
  > rttlib.color=true
  > print(TC)
  > -- get deployer peer. Lua methods are called with ':' notation
  > d = TC:getPeer("deployer")
  > print(d)
  > instead of print you can just type '='
  > =d
  > -- call an operation
  > d:call("displayComponentTypes")
  I can create the following component types:
     OCL::LuaComponent
     OCL::Testcomp
  >

  -- todo
#+END_EXAMPLE


* Lua API

** Overview

   All rtt related functions are stored in a global table called
   =rtt=. They are further subdivided as followed:

   - =TaskContext=
   - =Variable=
   - =InputPort= and =OutputPort=
   - =Property=
   - =SendHandle=
   - =Service=
   - =Operation=
   - =Logger=

     The flag column describes different properties of a function/method:
     - =RT=: real-time safe
     - =GC=: garbage collected object


** =TaskContext=

   | Method                                           | flag | description                                                         |
   |--------------------------------------------------+------+---------------------------------------------------------------------|
   | =string getName()=                               |      | returns TaskContext name                                            |
   | =bool start()=                                   |      | start TaskContext                                                   |
   | =bool stop()=                                    |      | stop TaskContext                                                    |
   | =bool configure()=                               |      | configure TaskContext                                               |
   | =bool activate()=                                |      | activate TaskContext                                                |
   | =bool cleanup()=                                 |      | cleanup TaskContext                                                 |
   | =string getState()=                              |      | return string describing current state                              |
   | =table getPeers()=                               |      | return a table of all peers                                         |
   | =void addPeer(TaskContext)=                      |      | add a TaskContext as a peer                                         |
   | =void removePeer(string)=                        |      | remove a peer                                                       |
   | =TaskContext getPeer(string)=                    |      | get a peer                                                          |
   | =table getPortNames()=                           |      | return a table of port names                                        |
   | =void addPort(port)=                             |      | add a port to TaskContext                                           |
   | =void addEventPort(port)=                        |      | add a port as an event driven port                                  |
   | =Port getPort(string)=                           |      | get a port with given name                                          |
   | =addProperty(Property)=                          |      | add a property to TaskContext                                       |
   | =getProperty(string)=                            |      | get a property with the given name                                  |
   | =table getProperties()=                          |      | return all properties in a table                                    |
   | =table getOps()=                                 |      | return a table of Operation names                                   |
   | =string, number string, table getOpInfo(string)= |      | returns name, arity, description and table of argument descriptions |
   | =Service provides(...)=                          |      | return service (provides/0 default, provides/1 subservice)          |
   | =Variable call(string, ...)=                     |      | call operation with name specified by string and right arguments    |
   | =SendHandle send(string, ...)=                   |      | as above but send. returns SendHandle                               |
   | =void delete(TaskContext)=                       |      | explicit deletion of a TaskContext                                  |



** =Variable=

** =InputPort= and =OutputPort=

* Pitfalls
* The =rttlib= convenience module
  This library adds some pretty printing functions to the standard
  objects.


** how to add a pretty printer for a custom type

   In short: write a function which accepts a lua table representation
   of you data type and returns either a table or a string. Assign it
   to =rttlib.pp_var.mytype=, where mytype is the value returned by
   the =var:getType()= method. Thats should do it.

   *Quick example:* =ConnPolicy= type

   (This is just an example. It has been done for this type already).

   If you run it without loading =rttlib= printing a =ConnPolicy= will
   look like this:

   #+BEGIN_EXAMPLE
   ./rttlua
   Orocos RTTLua 1.0-beta1 (gnulinux)
   > return var.new("ConnPolicy")
   {data_size=0,type=0,name_id="",init=false,pull=false,transport=0,lock_policy=2,size=0}
   #+END_EXAMPLE

   This not too bad, but we would like to display the string
   representation of the C++ enums =type= and =lock_policy=. So we
   write a function...

   #+BEGIN_EXAMPLE
   function ConnPolicy2tab(cp)
       if cp.type == 0 then cp.type = "DATA"
       elseif cp.type == 1 then cp.type = "BUFFER"
       else cp.type = tostring(cp.type) .. " (invalid!)" end

       if cp.lock_policy == 0 then cp.lock_policy = "UNSYNC"
       elseif cp.lock_policy == 1 then cp.lock_policy = "LOCKED"
       elseif cp.lock_policy == 2 then cp.lock_policy = "LOCK_FREE"
       else cp.lock_policy = tostring(cp.lock_policy) .. " (invalid!)" end
       return cp
   end
   #+END_EXAMPLE

   and add it to the =rttlib.var_pp= table of Variable formatters:

   #+BEGIN_EXAMPLE
   rttlib.var_pp.ConnPolicy = ConnPolicy2tab
   #+END_EXAMPLE

   now printing a =ConnPolicy= again calls our function and prints the
   desired fields:

   #+BEGIN_EXAMPLE
   > return var.new("ConnPolicy")
   {data_size=0,type="DATA",name_id="",init=false,pull=false,transport=0,lock_policy="LOCK_FREE",size=0}
   >
   #+END_EXAMPLE

* Tips and tricks
** Using functions instead of methods

** rttlua init file =~/.rttlua=

   =rttlua= will look for a file =.rttlua= in your home directory and
   if found execute it. It can be used for doing initalization
   (e.g. loading =rttlib= etc.)

* Known issues

  - Not all types are garbage collected.

  - Comparison of equivalent Lua and RTT Variable types is does *not*
    work. You can only compare entities of the _same_ type:

    #+BEGIN_EXAMPLE
    -- lua with lua works:
    > ="just a string" == "just a string"
    true
    -- and rtt.Variable with rtt.Variable too...
    > return rtt.Variable.new("string", "just a string") == rtt.Variable.new("string", "just a string")
    true
    -- but unfortunately not a mixture of both:
    > return "just a string" == rtt.Variable.new("string", "just a string")
    false
    #+END_EXAMPLE

* Todo

  - reintegrate tlsf and real-time validation
  - Support for creating Operations from Lua (probably not soon)
  -

* License

  The Lua-RTT bindings are licensed under the LGPL.

* Links
  - [[http://www.lua.org/][The Lua website]]
  - [[http://www.lua.org/pil/][Programming in Lua]] book (older version, but the basics are mostly the same)
  - [[http://www.lua.org/manual/5.1/][The Lua-5.1 Reference Manual]]
  - [[http://thomaslauer.com/download/luarefv51.pdf][Lua Cheatsheet]]
