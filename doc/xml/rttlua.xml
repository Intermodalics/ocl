<?xml version="1.0" encoding="utf-8"?>
<!-- Date: 2011-01-25 Tue -->
<!-- DocBook XML file generated by Org-mode TAG=7.01g Emacs 23 -->
<article xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
  <title>Lua RTT bindings (beta2)</title>
  <info>
    <author>
      <personname>
        <firstname>Markus</firstname> <othername></othername> <surname>Klotzbuecher</surname>
      </personname>
      
    </author>
  </info>
<section xml:id="sec-1">
<title>Overview </title>
<para>
The RTT Lua bindings provide a slim but powerful interface to the
RTT framework. It can be used for:
</para>
<itemizedlist>
<listitem>

<para>for building domain specific languages for the RTT
</para>
</listitem>
<listitem>
<para>as a scriptable taskbrowser and deployer
</para>
</listitem>
<listitem>
<para>for fast prototyping of components
</para>
</listitem>
</itemizedlist>

<para>These bindings can be used in three different ways:
</para>
<orderedlist>
<listitem>

<para>As a <emphasis role="bold">RTT enabled Lua interpreter</emphasis>
</para>

<para>
This is the easiest way to test a script and see if it works or
for use as a scriptable deployer.
</para>
</listitem>
<listitem>
<para>As a <emphasis role="bold">Lua component</emphasis>
</para>

<para>
A Lua component which offers two operations. The first for
executing a given lua script and the second for executing a
string with lua code.
</para>
</listitem>
<listitem>
<para>As a <emphasis role="bold">RTT plugin</emphasis>
</para>

<para>
A <emphasis>Lua Service</emphasis> can be loaded into a component and used e.g. for
<emphasis>intra-component</emphasis> coordination. It offers the same API as the
Lua component.
</para>
</listitem>
</orderedlist>
</section>

<section xml:id="sec-2">
<title>Setup </title>
<section xml:id="sec-2_1">
<title>Compilation </title>
<itemizedlist>
<listitem>

<para>requires Lua-5.1 (debian: <code>liblua5.1-0-dev</code>, <code>liblua5.1-0</code>, <code>lua5.1</code>)
</para>
</listitem>
<listitem>
<para>CMake options:
</para>
<itemizedlist>
<listitem>

<para><code>BUILD_LUA_RTT</code>: enable this to build the rttlua shell, the
Lua component and the Lua plugin.
</para>
</listitem>
<listitem>
<para><code>BUILD_LUA_RTT_DYNAMIC_MODULES</code>: (EXPERIMENTAL) build RTT and
deployer as pure Lua plugins. Don't use unless you know what
you are doing.
</para>
</listitem>
<listitem>
<para><code>BUILD_LUA_TESTCOMP</code>: builds a simple testcomponent which is
used for testing the bindings. Not required for normal
operation.
</para>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>

<section xml:id="sec-2_2">
<title>Runtime </title>
<itemizedlist>
<listitem>

<para>setup <code>LUA_PATH</code> and <code>LUA_CPATH</code> so that the rtt lua extension
modules are found. The former is for lua modules (.lua) and the
later is for binary ones (.so). For example:
</para>
</listitem>
</itemizedlist>


<programlisting><![CDATA[$ export LUA_PATH=";;;/home/mk/src/git/orocos/ocl/lua/modules/?.lua"
$ export LUA_CPATH=";;;/home/mk/src/git/orocos/ocl/lua/modules/?.so"
]]></programlisting>

<para>
(The first two semicolons mean the default path and the third
separates our path. See the <link xlink:href="http://www.lua.org/manual/5.1/manual.html#5.3">Lua reference manual</link> for more
information.)
</para>
<itemizedlist>
<listitem>

<para>if using <code>rttlua</code> scripting: export correct <code>RTT_COMPONENT_PATH</code>
variable, e.g.
</para>
</listitem>
</itemizedlist>


<programlisting><![CDATA[$ export RTT_COMPONENT_PATH=/home/mk/tmp/rtt-2.0/lib/orocos:home/mk/src/git/ocl/lua
]]></programlisting>

<para>
and (optionally) add the location of the <code>rttlua</code> binary to your
path, e.g.
</para>
<programlisting><![CDATA[export PATH=$PATH:/home/mk/src/git/ocl/lua
]]></programlisting>
</section>
</section>

<section xml:id="sec-3">
<title>Quickstart </title>
<section xml:id="sec-3_1">
<title>Using the RTT Lua interpreter </title>
<para>
Run the <code>rttlua</code> interpreter. <code>--</code> indicates a comment. <code>rttlua</code>
always creates a deployer which is available as peer of the "this"
TaskContext in which we are running. The latter can be retrieved
using the <code>rtt.getTC()</code> function.
</para>
<programlisting><![CDATA[./rttlua
Orocos RTTLua 1.0-beta1 (gnulinux)
> -- get a reference to our "this" TaskContext
> TC = rtt.getTC()
> -- print the TaskContext
> print(TC)
userdata: 0x1cba0b8
> -- if we want nicer output we must load the rttlib module
> require("rttlib")
> print(TC)
TaskContext: lua
state: PreOperational
[...]
> -- enable colors
> rttlib.color=true
> print(TC)
> -- get deployer peer. Lua methods are called with ':' notation
> d = TC:getPeer("deployer")
> print(d)
> instead of print you can just type '='
> =d
> -- call an operation
> d:displayComponentTypes()
I can create the following component types:
   OCL::LuaComponent
   OCL::Testcomp
> -- create a property
> p = rtt.Property.new("string", "myprop")
> -- add it to our TaskContext
> TC:addProperty(p)
> -- check if its there
> =TC
> -- change it
> p:set("hello world")
> -- if you print TC it should have changed too.
]]></programlisting>
</section>

<section xml:id="sec-3_2">
<title>Using the LuaComponent </title>
<para>
see the simple producer comsumer example in the
<code>scripts/producer_consumer/</code> directory.
</para>

<para>
The LuaComponent has two <code>string</code> properties called <code>lua_string</code>
and <code>lua_file</code>. The code in this string/file will be executed
during <code>configureHook</code> <emphasis role="underline">before</emphasis> the Lua configureHook() is
executed. E.g:
</para>
<programlisting><![CDATA[rttlua
Orocos RTTLua 1.0-beta1 (gnulinux)
> tc=getTC()
> tc:getProperty("lua_string"):set("print('hello property')")
> =tc:configure()
hello property
85.295 [ ERROR  ][./rttlua::main()] [string "configureHook()"]:1: attempt to call global 'configureHook' (a nil value)
false
]]></programlisting>

<para>
(The error occurs because we have not define a <code>configureHook</code> lua
function.)
</para>

<para>
The idea of course is to be able to use the standard deployer to
setup Lua components. If the properties are not initialized nothing
happens.
</para>
</section>

<section xml:id="sec-3_3">
<title>Using the LuaService </title>
<para>
Here's an snip of Lua code which creates a Lua service in the
deployer component, runs some Lua code in it which creates a
property and then checks if the value was set correctly. It also
shows how to correctly clean up a Property.
</para>
<programlisting><![CDATA[-- load lua service into deployer
d:addPeer(d)
d:loadService("deployer", "Lua")
local execstr_op = d:provides("Lua"):getOperation("exec_str")
execstr_op([[
                  require("rttlib")
                  local tc=rtt.getTC()
                  local p=rtt.Property.new("string", "service-testprop")
                  tc:addProperty(p)
                  p:set("hullo from the lua service!")
            ]])

 local p = d:getProperty("service-testprop")
 assert(p:get() == var.new("string", "hullo from the lua service!"))
 d:removeProperty("service-testprop")
 p:delete()
 d:removePeer("deployer")
]]></programlisting>
</section>
</section>

<section xml:id="sec-4">
<title>Lua API </title>
<section xml:id="sec-4_1">
<title>Overview </title>
<para>
The Lua API consists of objects and free functions. The API naming
mostly follows that RTT while simplifying where possible. All rtt
related functions are stored in a global table called <code>rtt</code>. They
are further subdivided as followed:
</para>
<itemizedlist>
<listitem>

<para><code>TaskContext</code>
</para>
</listitem>
<listitem>
<para><code>SendHandle</code>
</para>
</listitem>
<listitem>
<para><code>Variable</code>
</para>
</listitem>
<listitem>
<para><code>InputPort</code> and <code>OutputPort</code>
</para>
</listitem>
<listitem>
<para><code>Property</code>
</para>
</listitem>
<listitem>
<para><code>Service</code>
</para>
</listitem>
<listitem>
<para><code>Operation</code>
</para>
</listitem>
<listitem>
<para><code>Logger</code>
</para>
</listitem>
<listitem>
<para><code>EEHook</code>
</para>
</listitem>
</itemizedlist>

<para>Probably the most important function is <code>rtt.getTC()</code> which returns
a reference to <emphasis>our</emphasis> TaskContext.
</para>

<para>
<emphasis role="bold">Note</emphasis>: the API consists of what was needed so far and what was easy
to do. If something is missing which you need let us know. Chances
are high that it is easy to add.
</para>

<para>
Most of the API can be used in two ways: as functions and
objects. The first uses the dot '.' syntax and takes the object as
the first parameter. The second uses the ':' and will internally
pass the object as a first parameter.
</para>

<para>
For example the following two calls are equivalent:
</para>
<programlisting><![CDATA[> tc = rtt.getTC()
> print( rtt.TaskContext.getName(tc) )
> print( tc:getName() )
]]></programlisting>

<para>
The flag column describes additonal properties of the
function/method:
</para>
<itemizedlist>
<listitem>

<para>'R': real-time safe
</para>
</listitem>
<listitem>
<para>'F' or 'M': only available as function or method
</para>
</listitem>
<listitem>
<para>'D': deprecated
</para>
</listitem>
</itemizedlist>
</section>

<section xml:id="sec-4_2">
<title>Miscellaneous toplevel </title>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>table services()</code></td><td>F</td><td>returns a table of strings specifying the known services</td></tr>
<tr><td><code>table typekits()</code></td><td>F</td><td>returns a table of strings specifying the known typekits</td></tr>
<tr><td><code>table types()</code></td><td>F</td><td>returns a table of strings specifying the known types</td></tr>
<tr><td><code>setLogLevel(string)</code></td><td>F</td><td>set the loglevel</td></tr>
<tr><td><code>string getLogLevel()</code></td><td>F</td><td>return the current loglevel</td></tr>
<tr><td><code>log(string, ...)</code></td><td>F</td><td>log all (string) arguments</td></tr>
<tr><td><code>logl(loglevel, string, ...)</code></td><td>F</td><td>log all (string) arguments with (string) loglevel</td></tr>
</tbody>
</informaltable>
</section>

<section xml:id="sec-4_3">
<title>TaskContext </title>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>string getName()</code></td><td></td><td>returns TaskContext name</td></tr>
<tr><td><code>bool start()</code></td><td></td><td>start TaskContext</td></tr>
<tr><td><code>bool stop()</code></td><td></td><td>stop TaskContext</td></tr>
<tr><td><code>bool configure()</code></td><td></td><td>configure TaskContext</td></tr>
<tr><td><code>bool activate()</code></td><td></td><td>activate TaskContext</td></tr>
<tr><td><code>bool cleanup()</code></td><td></td><td>cleanup TaskContext</td></tr>
<tr><td><code>string getState()</code></td><td></td><td>return string describing current state</td></tr>
<tr><td><code>table getPeers()</code></td><td></td><td>return a table of all peers</td></tr>
<tr><td><code>void addPeer(TaskContext)</code></td><td></td><td>add a TaskContext as a peer</td></tr>
<tr><td><code>void removePeer(string)</code></td><td></td><td>remove a peer</td></tr>
<tr><td><code>TaskContext getPeer(string)</code></td><td></td><td>get a peer</td></tr>
<tr><td><code>table getPortNames()</code></td><td></td><td>return a table of port names</td></tr>
<tr><td><code>void addPort(port, name, desc)</code></td><td></td><td>add a port to TaskContext with name (optional) and description (optional)</td></tr>
<tr><td><code>void addEventPort(port, name, desc)</code></td><td></td><td>as above but add as EventPort</td></tr>
<tr><td><code>Port getPort(string)</code></td><td></td><td>get a port with given name</td></tr>
<tr><td><code>void removePort(string)</code></td><td></td><td>remove port with given name from interface</td></tr>
<tr><td><code>addProperty(Property, name, desc)</code></td><td></td><td>add a property with name (optional) and description (optional)</td></tr>
<tr><td><code>getProperty(string)</code></td><td></td><td>get a property with the given name</td></tr>
<tr><td><code>table getProperties()</code></td><td></td><td>return all properties in a table</td></tr>
<tr><td><code>void removeProperty(string)</code></td><td></td><td>remove property with given name from interface</td></tr>
<tr><td><code>table getOps()</code></td><td></td><td>return a table of Operation names</td></tr>
<tr><td><code>string, number string, table getOpInfo(string)</code></td><td></td><td>returns name, arity, description and table of argument descriptions</td></tr>
<tr><td><code>Service provides(...)</code></td><td></td><td>return service (provides/0 default, provides/1 subservice)</td></tr>
<tr><td><code>Variable call(string, ...)</code></td><td>D</td><td>call operation with name specified by string and right arguments</td></tr>
<tr><td><code>Operation getOperation(name)</code></td><td></td><td>get an Operation by string name</td></tr>
<tr><td><code>bool hasOperation(string)</code></td><td></td><td>return true if operation exists in this TaskContext</td></tr>
<tr><td><code>SendHandle send(string, ...)</code></td><td></td><td>as above but send. returns SendHandle</td></tr>
<tr><td><code>void delete(TaskContext)</code></td><td></td><td>explicit deletion of a TaskContext</td></tr>
</tbody>
</informaltable>


<para>
Note: <code>call</code> and <code>send</code> accept both Variables and Lua types.
</para>
</section>

<section xml:id="sec-4_4">
<title>SendHandle </title>
<para>
An object returned by a TaskContext send() operation.
</para>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>string, variable collect()</code></td><td></td><td>collect results of send, may block. string is SendStatus</td></tr>
<tr><td><code>string, variable collectIfDone</code></td><td></td><td>as above, non blocking version</td></tr>
</tbody>
</informaltable>
</section>

<section xml:id="sec-4_5">
<title>Variable </title>
<para>
Variable are the types know to the RTT. They consist of basic types
(numeric, <code>string</code>, <code>char</code>, <code>bool</code>) and user defined types. The
function <code>rtt.Variable.getTypes()</code> returns a table of these types:
</para>
<programlisting><![CDATA[> print(table.concat(rtt.Variable.getTypes(), ', '))
ConnPolicy, FlowStatus, PropertyBag, SendHandle, SendStatus, array, bool, char, double, float, int, rt_string, string, uint, void
]]></programlisting>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>variable new(type)</code></td><td>F</td><td>create a new Variable of type</td></tr>
<tr><td><code>variable new(type, ival)</code></td><td>F</td><td>create new Variable of type and initialize with ival (only for basic types)</td></tr>
<tr><td><code>luaval tolua()</code></td><td></td><td>convert to lua value (only for basic types)</td></tr>
<tr><td><code>table getTypes()</code></td><td>F</td><td>return a list of types know to the RTT</td></tr>
<tr><td><code>string getType()</code></td><td></td><td>return the RTT type name in human readable format</td></tr>
<tr><td><code>string getTypeName()</code></td><td></td><td>return the RTT type name</td></tr>
<tr><td><code>table getMemberNames()</code></td><td></td><td>return a table of the names of subtypes of this variable</td></tr>
<tr><td><code>variable getMember(name)</code></td><td></td><td>return variable which is a member with name</td></tr>
<tr><td><code>opBinary(string_op, var1, var2)</code></td><td>F</td><td>execute: var1 string<subscript>op</subscript> var2</td></tr>
<tr><td><code>bool assign(value)</code></td><td></td><td>assign value which can be a lua type or a Variable</td></tr>
<tr><td><code>bool resize(size)</code></td><td></td><td>resize type (only for array types)</td></tr>
</tbody>
</informaltable>
<itemizedlist>
<listitem>

<para>the unary operator <code>-</code> and the binary operators <code>+</code>, <code>-</code>, <code>*</code>,
<code>/</code> <code>%</code>, <code>^</code>, and the comparison operators '==', '&lt;=', '&gt;=' are
supported. See the <link linkend="#ComparisonIssue">warning</link> on comparing Variables with
corresponding Lua types.
</para>
</listitem>
<listitem>
<para>indexing and assigment
</para>

<para>
Variables with members can be indexed and assigned. See the
following example:
</para>
</listitem>
</itemizedlist>


<programlisting><![CDATA[> cp = rtt.Variable.new("ConnPolicy")
> print(cp)
{data_size=0,type=0,name_id="",init=false,pull=false,transport=0,lock_policy=2,size=0}
> print(cp.data_size)
0
> cp.data_size = 4711
> print(cp.data_size)
4711
]]></programlisting>
</section>

<section xml:id="sec-4_6">
<title>InputPort and OutputPort </title>
<para>
InputPort
</para>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>new(type, name, desc)</code></td><td></td><td>create a new InputPort of type  with name (optional) and description (optional)</td></tr>
<tr><td><code>string, variable read()</code></td><td></td><td>read from Port, returns a FlowStatus string and if data available a Variable</td></tr>
<tr><td><code>string read(variable)</code></td><td></td><td>read from Port and write result into Variable given. Returns FlowStatus</td></tr>
<tr><td><code>table info()</code></td><td></td><td>return a table containing information about this port</td></tr>
<tr><td><code>bool connect(port)</code></td><td></td><td>connect this port to the given one</td></tr>
<tr><td><code>delete()</code></td><td></td><td>delete this port (remove it from any TaskContext before this)</td></tr>
</tbody>
</informaltable>


<para>
OuputPort
</para>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>new(type, name, desc)</code></td><td></td><td>create a new OutputPort of type with name (optional) and description (optional)</td></tr>
<tr><td><code>write(Variable)</code></td><td></td><td>write Variable to port</td></tr>
<tr><td><code>table info()</code></td><td></td><td>return a table containing information about this port</td></tr>
<tr><td><code>bool connect(port)</code></td><td></td><td>connect this port to the given one</td></tr>
<tr><td><code>delete()</code></td><td></td><td>delete this port (remove it from any TaskContext before this)</td></tr>
</tbody>
</informaltable>
</section>

<section xml:id="sec-4_7">
<title>Property </title>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>new(type, name, desc)</code></td><td></td><td>create a new Property of type  with name (optional) and description (optional)</td></tr>
<tr><td><code>Variable get()</code></td><td></td><td>return the Variable contained in this Property</td></tr>
<tr><td><code>bool set(Variable)</code></td><td></td><td>set the Property to the value in given Variable</td></tr>
<tr><td><code>string getName()</code></td><td></td><td>return the name of the property</td></tr>
<tr><td><code>string getDescription()</code></td><td></td><td>return the description of the property</td></tr>
<tr><td><code>delete()</code></td><td></td><td>delete this property (remove it from any TaskContex before doing this!)</td></tr>
</tbody>
</informaltable>


<para>
Properties which contain complex types can also be indexed with <code>.</code>
just like Variables.
</para>
</section>

<section xml:id="sec-4_8">
<title>Service Interface </title>
<section xml:id="sec-4_8_1">
<title>Service </title>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>string getName()</code></td><td></td><td>return Name of Service</td></tr>
<tr><td><code>string doc()</code></td><td></td><td>return documentation of this service</td></tr>
<tr><td><code>table getProviderNames()</code></td><td></td><td>return table of subservice names</td></tr>
<tr><td><code>table getOperationNames()</code></td><td></td><td>return table of names of operations of this service</td></tr>
<tr><td><code>table getPortNames()</code></td><td></td><td>return table of names of ports of this service</td></tr>
<tr><td><code>provides(string)</code></td><td></td><td>return subservice with name specified by given string</td></tr>
<tr><td><code>Operation getOperation(string)</code></td><td></td><td>return operation specified by string name  of this service</td></tr>
<tr><td><code>bool hasOperation(string)</code></td><td></td><td>return true if operation exists in this service</td></tr>
<tr><td><code>Port getPort(string)</code></td><td></td><td>return port specified by the given string name of this service</td></tr>
</tbody>
</informaltable>
</section>

<section xml:id="sec-4_8_2">
<title>ServiceRequester </title>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>string getRequestName()</code></td><td></td><td>return name of this service requester</td></tr>
<tr><td><code>table getRequesterNames()</code></td><td></td><td>return table of names of required subservices</td></tr>
<tr><td><code>bool ready()</code></td><td></td><td>true if all operations are resolved</td></tr>
<tr><td><code>void disconnect()</code></td><td></td><td>disconnect from remote Service</td></tr>
<tr><td><code>requires(string)</code></td><td></td><td>return required subservice specified by string name</td></tr>
</tbody>
</informaltable>
</section>

<section xml:id="sec-4_8_3">
<title>Operation </title>
<para>
This object is only returned by <code>Service:getOperation</code>. It can
also be called with the familiar <code>op(arg1, arg2)</code> syntax.
</para>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>name, descr, res_type, arity, argtab info()</code></td><td></td><td>returns result type, arity, description and table of parameters</td></tr>
<tr><td><code>Variable call(string, ...)</code></td><td></td><td>calls operation specified by string. additional args are passed on</td></tr>
<tr><td><code>SendHandle send(string, ...)</code></td><td></td><td>same as above, but <code>send</code> Operation and return SendHandle</td></tr>
</tbody>
</informaltable>
</section>

<section xml:id="sec-4_8_4">
<title>EEHook </title>
<para>
EEHook provides a way to register callbacks in the TaskContexts
Execution engine. This is especially useful for the Lua plugin
which can use this mechanism to get triggered on every update
hook.
</para>
<informaltable border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<thead>
<tr><th scope="col">Method</th><th scope="col">flag</th><th scope="col">description</th></tr>
</thead>
<tbody>
<tr><td><code>new(name)</code></td><td></td><td>create a new hook tied to the lua function with the given (string) name</td></tr>
<tr><td><code>bool enable()</code></td><td></td><td>enable the hook so the lua function will be executed on trigger()</td></tr>
<tr><td><code>bool disable()</code></td><td></td><td>disable the hook</td></tr>
</tbody>
</informaltable>
</section>
</section>
</section>

<section xml:id="sec-5">
<title>The rttlib convenience module </title>
<para>This library adds some useful (mostly pretty printing) functions to
the standard objects. It is recommended to load it for all
applications by adding the following to scripts:
</para>

<para>
<code>require("rttlib")</code>
</para>
<section xml:id="sec-5_1">
<title>how to add a pretty printer for a custom type </title>
<para>
In short: write a function which accepts a lua table representation
of you data type and returns either a table or a string. Assign it
to <code>rttlib.var_pp.mytype</code>, where mytype is the value returned by
the <code>var:getType()</code> method. That's all!
</para>

<para>
<emphasis role="bold">Quick example:</emphasis> <code>ConnPolicy</code> type
</para>

<para>
(This is just an example. It has been done for this type already).
</para>

<para>
If you run it without loading <code>rttlib</code> printing a <code>ConnPolicy</code> will
look like this:
</para>
<programlisting><![CDATA[./rttlua
Orocos RTTLua 1.0-beta1 (gnulinux)
> return var.new("ConnPolicy")
{data_size=0,type=0,name_id="",init=false,pull=false,transport=0,lock_policy=2,size=0}
]]></programlisting>

<para>
This not too bad, but we would like to display the string
representation of the C++ enums <code>type</code> and <code>lock_policy</code>. So we
write a function must return a table...
</para>
<programlisting><![CDATA[function ConnPolicy2tab(cp)
    if cp.type == 0 then cp.type = "DATA"
    elseif cp.type == 1 then cp.type = "BUFFER"
    else cp.type = tostring(cp.type) .. " (invalid!)" end

    if cp.lock_policy == 0 then cp.lock_policy = "UNSYNC"
    elseif cp.lock_policy == 1 then cp.lock_policy = "LOCKED"
    elseif cp.lock_policy == 2 then cp.lock_policy = "LOCK_FREE"
    else cp.lock_policy = tostring(cp.lock_policy) .. " (invalid!)" end
    return cp
end
]]></programlisting>

<para>
and add it to the <code>rttlib.var_pp</code> table of Variable formatters:
</para>
<programlisting><![CDATA[rttlib.var_pp.ConnPolicy = ConnPolicy2tab
]]></programlisting>

<para>
now printing a <code>ConnPolicy</code> again calls our function and prints the
desired fields:
</para>
<programlisting><![CDATA[> return var.new("ConnPolicy")
{data_size=0,type="DATA",name_id="",init=false,pull=false,transport=0,lock_policy="LOCK_FREE",size=0}
>
]]></programlisting>
</section>
</section>

<section xml:id="sec-6">
<title>Tips and tricks </title>
<section xml:id="sec-6_1">
<title>rttlua init file <code>~/.rttlua</code> </title>
<para>
<code>rttlua</code> will look for a file <code>.rttlua</code> in your home directory and
if found execute it. It can be used for doing initalization
(e.g. loading <code>rttlib</code> etc.)
</para>
</section>
</section>

<section xml:id="sec-7">
<title>Known issues </title>
<section xml:id="sec-7_1">
<title>Assignment is not like RTT scripting </title>
<para>
Except for the Lua primitive types (string, number, boolean) Lua
works with references. So assignment between RTT Variables and Lua
types might not do what you expect:
</para>
<programlisting><![CDATA[> s=rtt.Variable.new("string", "hello world")
> print(s)
hello world
> =type(s)
userdata
> =s:getType()
string
> s = "a new string" -- carful! now its a Lua string, the former Variable will be garbage collected.
> =type(s)
string
> s:getType()
stdin:1: attempt to call method 'getType' (a nil value)
stack traceback:
stdin:1: in main chunk
]]></programlisting>
</section>

<section xml:id="sec-7_2">
<title>Not all types are garbage collected </title>
<para>
The following types are not garbage collected and must be managed
manually (ie. removed from TaskContext Interface and the delete()
function called):
</para>
<itemizedlist>
<listitem>

<para>Property
</para>
</listitem>
<listitem>
<para>InputPort, OutputPort
</para>
</listitem>
<listitem>
<para>TaskContext
</para>
</listitem>
</itemizedlist>

<para>(For completenes, these types <emphasis role="underline">are</emphasis> collected: Variable, Service,
ServiceRequester, SendHandle, Operation, EEHook)
</para>
</section>

<section xml:id="sec-7_3">
<title>Comparing Lua types and RTT Variables fails </title>
<para>
Comparison of equivalent Lua and RTT Variable types is does <emphasis role="bold">not</emphasis>
work. You can only compare entities of the <emphasis role="underline">same</emphasis> type:
</para>
<programlisting><![CDATA[-- lua with lua works:
> ="just a string" == "just a string"
true
-- and rtt.Variable with rtt.Variable too...
> return rtt.Variable.new("string", "just a string") == rtt.Variable.new("string", "just a string")
true
-- but unfortunately not a mixture of both:
> return "just a string" == rtt.Variable.new("string", "just a string")
false
]]></programlisting>
</section>

<section xml:id="sec-7_4">
<title>Calling a connected OperationCaller </title>
<para>
It is not possible to call a connected OperationCaller from Lua.
</para>
</section>

<section xml:id="sec-7_5">
<title>Support for creating Operations from Lua </title>
<para>
It is currently not possible to define new Operations from Lua.
</para>
</section>
</section>

<section xml:id="sec-8">
<title>License </title>
<para>
The Lua-RTT bindings are licensed under the same license as the
<link xlink:href="http://orocos.org/orocos/license">OROCOS RTT</link>.
</para>
</section>

<section xml:id="sec-9">
<title>Links </title>
<itemizedlist>
<listitem>

<para><link xlink:href="http://www.lua.org/">The Lua website</link>
</para>
</listitem>
<listitem>
<para><link xlink:href="http://www.lua.org/pil/">Programming in Lua</link> book (older version, but the basics are mostly the same)
</para>
</listitem>
<listitem>
<para><link xlink:href="http://www.lua.org/manual/5.1/">The Lua-5.1 Reference Manual</link>
</para>
</listitem>
<listitem>
<para><link xlink:href="http://thomaslauer.com/download/luarefv51.pdf">Lua Cheatsheet</link>
</para>
</listitem>
</itemizedlist>
</section>
</article>